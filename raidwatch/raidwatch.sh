#!/usr/bin/env bash
# Copyright Roman Glos 2026
# raidwatch.sh v1.01
# Universal RAID/Pool Watch (mdraid/btrfs/zfs) mit HTML Mail-Report

set -euo pipefail
export PATH="/usr/local/sbin:/usr/sbin:/sbin:/usr/local/bin:/usr/bin:/bin:${PATH:-}"

SCRIPT_NAME="$(basename "${BASH_SOURCE[0]}")"
SCRIPT_VERSION="v1.01"
SCRIPT_ID="${SCRIPT_NAME} ${SCRIPT_VERSION}"

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ENV_FILE="${RAIDWATCH_ENV:-$SCRIPT_DIR/raidwatch.env}"

# Preserve CLI/exported REPORT_LANG so it can override raidwatch.env
REPORT_LANG_CLI="${REPORT_LANG:-}"

if [[ -f "$ENV_FILE" ]]; then
  set -a
  # shellcheck disable=SC1090
  source "$ENV_FILE"
  set +a
else
  echo "WARN: raidwatch.env not found at $ENV_FILE, using defaults." >&2
fi

NAS_NAME="${NAS_NAME:-$(hostname -s 2>/dev/null || hostname)}"

# Language selection: raidwatch.env sets defaults, CLI/env can override
if [[ -n "${REPORT_LANG_CLI}" ]]; then
  REPORT_LANG="${REPORT_LANG_CLI}"
else
  REPORT_LANG="${REPORT_LANG:-de}"
fi
# Normalize (strip CR/whitespace, lower-case, map to en/de)
REPORT_LANG="${REPORT_LANG//$'\r'/}"
REPORT_LANG="${REPORT_LANG,,}"
REPORT_LANG="${REPORT_LANG#"${REPORT_LANG%%[![:space:]]*}"}"
REPORT_LANG="${REPORT_LANG%"${REPORT_LANG##*[![:space:]]}"}"
case "${REPORT_LANG}" in
  en|en_*|en-*) REPORT_LANG="en" ;;
  de|de_*|de-*) REPORT_LANG="de" ;;
  *) REPORT_LANG="de" ;;
esac
SUBJECT_PREFIX="${SUBJECT_PREFIX:-[RAID]}"

CHECK_MDRAID="${CHECK_MDRAID:-1}"
CHECK_BTRFS="${CHECK_BTRFS:-1}"
CHECK_ZFS="${CHECK_ZFS:-0}"

ALERT_ON_CHANGE="${ALERT_ON_CHANGE:-0}"
ALERT_COOLDOWN_SECONDS="${ALERT_COOLDOWN_SECONDS:-3600}"

SLEEP_SECONDS="${SLEEP_SECONDS:-60}"

SMTP_STARTTLS="${SMTP_STARTTLS:-1}"
SMTP_SSL="${SMTP_SSL:-0}"
SMTP_TIMEOUT="${SMTP_TIMEOUT:-20}"

MAIL_FORMAT="${MAIL_FORMAT:-html}"          # html | text
HTML_SHOW_DETAILS="${HTML_SHOW_DETAILS:-1}" # 1 | 0

LOG_RETENTION_DAYS="${LOG_RETENTION_DAYS:-30}"
LOG_MAX_MB="${LOG_MAX_MB:-5}"
LOG_ROTATE_COUNT="${LOG_ROTATE_COUNT:-3}"

MODE="once"
FORCE_SEND="0"
TEST_MAIL="0"

if [[ -z "${LOG_DIR:-}" ]]; then
  LOG_DIR="$SCRIPT_DIR/raidwatch-logs"
fi

mkdir -p "$LOG_DIR" >/dev/null 2>&1 || true

LOG_FILE="${LOG_DIR}/raidwatch_$(date '+%Y-%m').log"
STATE_FILE="${LOG_DIR}/raidwatch_state.env"
BAYMAP_FILE="${LOG_DIR}/raidwatch_baymap.json"

is_en() {
  [[ "${REPORT_LANG}" == "en" ]]
}

msg() {
  local k="${1:-}"
  if is_en; then
    case "$k" in
      USAGE_TITLE) echo "Usage: $(basename "$0") [--once|--loop] [--force] [--test-mail]" ;;
      USAGE_ONCE) echo "--once       Run once and exit" ;;
      USAGE_LOOP) echo "--loop       Endless loop (every SLEEP_SECONDS)" ;;
      USAGE_FORCE) echo "--force      Send mail even if no change/problem was detected" ;;
      USAGE_TEST) echo "--test-mail  Send test mail (no checks)" ;;
      FOOTER_NOTE) echo "Note: This report was automatically generated by ${SCRIPT_ID}." ;;
      FOOTER_COPYRIGHT) echo "Copyright Roman Glos 2026." ;;
      UNKNOWN_ARG) echo "Unknown:" ;;
      LOOP_STARTED) echo "Loop started" ;;
      TESTMAIL_SENT) echo "Test mail sent." ;;
      NO_MAIL_NEEDED) echo "No mail needed. Status:" ;;
      MAIL_SENT) echo "Mail sent:" ;;
      MAIL_SEND_FAILED) echo "ERROR: Mail sending failed." ;;
      PYTHON_MISSING) echo "ERROR: python3 not found, cannot send mail." ;;
      SMTP_CFG_INCOMPLETE) echo "Mail config incomplete (SMTP_SERVER/SMTP_PORT/MAIL_FROM/MAIL_TO)." ;;
      MDSTAT_NOT_READABLE) echo "/proc/mdstat not readable." ;;
      MD_NO_ARRAYS) echo "No md arrays found." ;;
      MDADM_MISSING) echo "Note: mdadm not found, using only /proc/mdstat." ;;
      *) echo "$k" ;;
    esac
  else
    case "$k" in
      USAGE_TITLE) echo "Usage: $(basename "$0") [--once|--loop] [--force] [--test-mail]" ;;
      USAGE_ONCE) echo "--once       Einmal prüfen und beenden" ;;
      USAGE_LOOP) echo "--loop       Endlosschleife (alle SLEEP_SECONDS)" ;;
      USAGE_FORCE) echo "--force      Mail senden, auch wenn kein Change/Problem erkannt wurde" ;;
      USAGE_TEST) echo "--test-mail  Testmail senden (ohne Checks)" ;;
      FOOTER_NOTE) echo "Hinweis: Dieser Report wurde automatisch vom Skript ${SCRIPT_ID} erzeugt." ;;
      FOOTER_COPYRIGHT) echo "Copyright Roman Glos 2026." ;;
      UNKNOWN_ARG) echo "Unbekannt:" ;;
      LOOP_STARTED) echo "Loop gestartet" ;;
      TESTMAIL_SENT) echo "Testmail gesendet." ;;
      NO_MAIL_NEEDED) echo "Keine Mail nötig. Status:" ;;
      MAIL_SENT) echo "Mail gesendet:" ;;
      MAIL_SEND_FAILED) echo "FEHLER: Mailversand fehlgeschlagen." ;;
      PYTHON_MISSING) echo "FEHLER: python3 nicht gefunden, kann keine Mail senden." ;;
      SMTP_CFG_INCOMPLETE) echo "Mail-Konfiguration unvollständig (SMTP_SERVER/SMTP_PORT/MAIL_FROM/MAIL_TO)." ;;
      MDSTAT_NOT_READABLE) echo "/proc/mdstat nicht lesbar." ;;
      MD_NO_ARRAYS) echo "Keine md-Arrays gefunden." ;;
      MDADM_MISSING) echo "Hinweis: mdadm nicht gefunden, nutze nur /proc/mdstat." ;;
      *) echo "$k" ;;
    esac
  fi
}

usage() {
  cat <<EOF
$(msg USAGE_TITLE)

$(msg USAGE_ONCE)
$(msg USAGE_LOOP)
$(msg USAGE_FORCE)
$(msg USAGE_TEST)
EOF
}

rotate_logs_if_needed() {
  find "$LOG_DIR" -name 'raidwatch_*.log*' -type f -mtime +"$LOG_RETENTION_DAYS" -delete 2>/dev/null || true

  local max_bytes=$(( LOG_MAX_MB * 1024 * 1024 ))
  [[ -f "$LOG_FILE" ]] || { : >"$LOG_FILE"; return 0; }

  local size
  size="$(wc -c <"$LOG_FILE" 2>/dev/null || echo 0)"
  if (( size < max_bytes )); then
    return 0
  fi

  local i
  for ((i=LOG_ROTATE_COUNT; i>=1; i--)); do
    if [[ -f "${LOG_FILE}.${i}" ]]; then
      if (( i == LOG_ROTATE_COUNT )); then
        rm -f "${LOG_FILE}.${i}" 2>/dev/null || true
      else
        mv -f "${LOG_FILE}.${i}" "${LOG_FILE}.$((i+1))" 2>/dev/null || true
      fi
    fi
  done

  mv -f "$LOG_FILE" "${LOG_FILE}.1" 2>/dev/null || true
  : >"$LOG_FILE"
}

log() {
  rotate_logs_if_needed
  local ts
  ts="$(date '+%d.%m.%Y %H:%M:%S' 2>/dev/null || date)"
  printf '[%s] %s\n' "$ts" "$*" | tee -a "$LOG_FILE" >/dev/null
}

trim_subject_64() {
  local s="$1"
  if ((${#s} <= 64)); then
    printf "%s" "$s"
  else
    printf "%s" "${s:0:64}"
  fi
}

hash_text() {
  local text="$1"
  if command -v sha256sum >/dev/null 2>&1; then
    printf "%s" "$text" | sha256sum | awk '{print $1}'
  else
    python3 -c 'import hashlib,sys;print(hashlib.sha256(sys.stdin.buffer.read()).hexdigest())' <<<"$text"
  fi
}

load_state() {
  LAST_HASH=""
  LAST_PROBLEM="0"
  LAST_ALERT_EPOCH="0"
  if [[ -f "$STATE_FILE" ]]; then
    # shellcheck disable=SC1090
    source "$STATE_FILE" || true
  fi
}

save_state() {
  local new_hash="$1"
  local new_problem="$2"
  local new_alert_epoch="$3"
  umask 077
  cat >"$STATE_FILE" <<EOF
LAST_HASH="${new_hash}"
LAST_PROBLEM="${new_problem}"
LAST_ALERT_EPOCH="${new_alert_epoch}"
EOF
}

check_mdraid() {
  local problem="0"
  local out=""

  if [[ ! -r /proc/mdstat ]]; then
    out+="[MD] $(msg MDSTAT_NOT_READABLE)\n"
    printf "%s|%b" "$problem" "$out"
    return 0
  fi

  out+="[MD] /proc/mdstat:\n"
  out+="$(cat /proc/mdstat)\n"

  mapfile -t arrays < <(awk '/^md[0-9]+/ {print $1}' /proc/mdstat 2>/dev/null || true)
  if ((${#arrays[@]} == 0)); then
    out+="[MD] $(msg MD_NO_ARRAYS)\n"
    printf "%s|%b" "$problem" "$out"
    return 0
  fi

  for md in "${arrays[@]}"; do
    local mdblock
    mdblock="$(awk -v m="$md" '$1==m {print;getline;print;getline;print}' /proc/mdstat 2>/dev/null || true)"

    if echo "$mdblock" | grep -Eq '\[[0-9]+/[0-9]+\]'; then
      local frac a b
      frac="$(echo "$mdblock" | grep -oE '\[[0-9]+/[0-9]+\]' | tail -n1 | tr -d '[]')"
      a="${frac%/*}"
      b="${frac#*/}"
      [[ "$a" != "$b" ]] && problem="1"
    fi

    if echo "$mdblock" | grep -Eq 'resync|recovery|rebuild|reshape|check|_'; then
      problem="1"
    fi

    if command -v mdadm >/dev/null 2>&1; then
      local detail
      detail="$(mdadm --detail "/dev/$md" 2>&1 || true)"
      out+="\n[MD] mdadm --detail /dev/$md:\n$detail\n"
      if echo "$detail" | grep -Eqi 'State :.*degraded|faulty|removed|inactive|recovering|resyncing|rebuilding'; then
        problem="1"
      fi
    else
      out+="\n[MD] $(msg MDADM_MISSING)\n"
    fi
  done

  printf "%s|%b" "$problem" "$out"
}

check_btrfs() {
  local problem="0"
  local out=""

  if ! command -v btrfs >/dev/null 2>&1; then
    printf "%s|%b" "$problem" "$out"
    return 0
  fi

  mapfile -t mnts < <(findmnt -t btrfs -n -o TARGET 2>/dev/null || true)
  if ((${#mnts[@]} == 0)); then
    printf "%s|%b" "$problem" "$out"
    return 0
  fi

  for m in "${mnts[@]}"; do
    out+="\n[BTRFS] Mount: $m\n"
    local show stats
    show="$(btrfs filesystem show "$m" 2>&1 || true)"
    out+="[BTRFS] filesystem show:\n$show\n"
    if echo "$show" | grep -qi "missing"; then
      problem="1"
    fi

    stats="$(btrfs device stats -c "$m" 2>&1 || true)"
    out+="[BTRFS] device stats -c:\n$stats\n"
    if echo "$stats" | awk '{v=$NF+0} v>0 {exit 10} END{exit 0}'; then
      :
    else
      problem="1"
    fi
  done

  printf "%s|%b" "$problem" "$out"
}

check_zfs() {
  local problem="0"
  local out=""
  if ! command -v zpool >/dev/null 2>&1; then
    printf "%s|%b" "$problem" "$out"
    return 0
  fi

  local x
  x="$(zpool status -x 2>&1 || true)"
  out+="[ZFS] zpool status -x:\n$x\n"

  if ! echo "$x" | grep -qi "all pools are healthy"; then
    problem="1"
    out+="\n[ZFS] Full status:\n$(zpool status 2>&1 || true)\n"
  fi

  printf "%s|%b" "$problem" "$out"
}

build_report_text() {
  local problem="0"
  local report=""

  if is_en; then
    report+="RAID Watch Report\n"
    report+="Time: $(date '+%d.%m.%Y %H:%M:%S' 2>/dev/null || date)\n"
    report+="Host: ${NAS_NAME}\n"
  else
    report+="RAID Watch Report\n"
    report+="Zeit: $(date '+%d.%m.%Y %H:%M:%S' 2>/dev/null || date)\n"
    report+="Host: ${NAS_NAME}\n"
  fi
  report+="Uname: $(uname -a 2>/dev/null || true)\n\n"

  if [[ "$CHECK_MDRAID" == "1" ]]; then
    local r p o
    r="$(check_mdraid)"
    p="${r%%|*}"
    o="${r#*|}"
    report+="$o\n"
    [[ "$p" == "1" ]] && problem="1"
  fi

  if [[ "$CHECK_BTRFS" == "1" ]]; then
    local r p o
    r="$(check_btrfs)"
    p="${r%%|*}"
    o="${r#*|}"
    [[ -n "$o" ]] && report+="$o\n"
    [[ "$p" == "1" ]] && problem="1"
  fi

  if [[ "$CHECK_ZFS" == "1" ]]; then
    local r p o
    r="$(check_zfs)"
    p="${r%%|*}"
    o="${r#*|}"
    [[ -n "$o" ]] && report+="$o\n"
    [[ "$p" == "1" ]] && problem="1"
  fi

  printf "%s|%b" "$problem" "$report"
}

make_html_report() {
  local kind="$1"
  local text_report="$2"

  if ! command -v python3 >/dev/null 2>&1; then
    printf ""
    return 0
  fi

  local tmp
  tmp="$(mktemp /tmp/raidwatch_report.XXXXXX)"
  printf "%s" "$text_report" >"$tmp"

  RW_LANG="$REPORT_LANG" KIND="$kind" NAS="$NAS_NAME" SHOW_DETAILS="$HTML_SHOW_DETAILS" BAYMAP_FILE="$BAYMAP_FILE" python3 - "$tmp" <<'PY'
import sys, os, re, json, html, subprocess, datetime, glob

tmp_path = sys.argv[1]
try:
  with open(tmp_path, "r", encoding="utf-8", errors="replace") as f:
    details_text = f.read()
except Exception:
  details_text = ""

kind = os.environ.get("KIND","OK")
nas  = os.environ.get("NAS","NAS")
lang = os.environ.get("RW_LANG","de").lower()
show_details = os.environ.get("SHOW_DETAILS","1") == "1"

now = datetime.datetime.now().strftime("%d.%m.%Y %H:%M:%S")

T = {
  "de": {
    "title": "RAID-Report für",
    "status": "Status",
    "time": "Zeitpunkt",
    "host": "Host",
    "md": "MD RAID",
    "details": "Details",
    "note": "Hinweis: Dieser Report wurde automatisch vom Skript raidwatch.sh v1.01 erzeugt.\nCopyright Roman Glos 2026.",
    "no_arrays": "Keine md-Arrays gefunden.",
    "array": "Array",
    "mount": "Volume",
    "level": "RAID-Level",
    "state": "Status",
    "active": "Aktiv/Gesamt",
    "failed": "Defekt",
    "spare": "Reserve",
    "progress": "Fortschritt",
    "speed": "Tempo/ETA",
    "member_table": "Laufwerke",
    "bay": "Schacht",
    "disk": "Datenträger",
    "role": "Rolle/Status",
    "model": "Modell",
    "serial": "Seriennummer",
    "missing_role": "fehlend/entfernt",
  },
  "en": {
    "title": "RAID report for",
    "status": "Status",
    "time": "Time",
    "host": "Host",
    "md": "MD RAID",
    "details": "Details",
    "note": "Note: This report was automatically generated by raidwatch.sh v1.01.\nCopyright Roman Glos 2026.",
    "no_arrays": "No md arrays found.",
    "array": "Array",
    "mount": "Mount",
    "level": "RAID level",
    "state": "State",
    "active": "Active/Total",
    "failed": "Failed",
    "spare": "Spare",
    "progress": "Progress",
    "speed": "Speed/ETA",
    "member_table": "Drives",
    "bay": "Bay",
    "disk": "Disk",
    "role": "Role/State",
    "model": "Model",
    "serial": "Serial",
    "missing_role": "missing/removed",
  }
}
tr = T["en"] if lang == "en" else T["de"]

baymap_path = os.environ.get("BAYMAP_FILE","")
baymap_data = {}
baymap_dirty = False
if baymap_path:
  try:
    with open(baymap_path, "r", encoding="utf-8", errors="replace") as f:
      baymap_data = json.load(f) or {}
  except Exception:
    baymap_data = {}

def run(cmd, timeout=6):
  try:
    p = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, timeout=timeout, check=False)
    return p.stdout or ""
  except Exception as e:
    return f"{cmd}: {e}"

def parent_disk(devpath):
  m = re.match(r"^(/dev/[a-z]+)(\d+)$", devpath)
  if m:
    return m.group(1)
  m = re.match(r"^(/dev/nvme\d+n\d+)p\d+$", devpath)
  if m:
    return m.group(1)
  return devpath

def get_mountpoints_for_kname(kname):
  mp = set()
  try:
    out = run(["lsblk","-J","-o","NAME,KNAME,TYPE,MOUNTPOINT,FSTYPE"], timeout=6)
    data = json.loads(out) if out.strip() else {}
  except Exception:
    return []

  def walk(node, under=False):
    name = node.get("name") or ""
    k = node.get("kname") or name
    is_target = (name == kname or k == kname)
    now_under = under or is_target
    if now_under:
      mpt = node.get("mountpoint") or ""
      if mpt:
        mp.add(mpt)
    for ch in node.get("children", []) or []:
      walk(ch, now_under)

  for n in data.get("blockdevices", []) or []:
    walk(n, False)

  return sorted(mp)

def label_from_mount(mps):
  if not mps:
    return ""
  for m in mps:
    mm = re.match(r"^/volume(\d+)", m)
    if mm:
      num = mm.group(1)
      return f"Volume {num} ({m})" if lang != "en" else f"Volume {num} ({m})"
  return ", ".join(mps)

# SATA bay mapping (HDD Bays)
# Prefer /dev/disk/by-path (stable port order, survives re-enumeration),
# fallback to lsblk -S HCTL host mapping (like monthly_smart_longtest.sh).
bay_map = {}
bay_to_dev = {}
present_sata_bays = set()
sata_bay_count = 0
scsi_info = {}
try:
  # 1) Collect model/serial + optional HCTL host mapping (fallback)
  out = run(["lsblk","-S","-x","hctl","-o","NAME,HCTL,MODEL,SERIAL","-J"], timeout=6)
  data = json.loads(out) if out.strip() else {}

  # configured disks (sd*) - no partitions
  configured = []
  try:
    out2 = run(["lsblk","-dn","-o","NAME,TYPE"], timeout=6)
    for line in out2.splitlines():
      parts = line.split()
      if len(parts) != 2:
        continue
      name, typ = parts
      if typ != "disk":
        continue
      if name.startswith("sd"):
        configured.append("/dev/" + name)
  except Exception:
    configured = []

  host_to_dev = {}
  hosts = set()

  def _safe_int(val, default=None):
    try:
      return int(val)
    except Exception:
      return default

  # collect SCSI host -> device and model/serial
  for dev in data.get("blockdevices", []):
    name = dev.get("name")
    if not name or not name.startswith("sd"):
      continue
    path = "/dev/" + name
    hctl = dev.get("hctl") or ""
    model = dev.get("model") or ""
    serial = dev.get("serial") or ""
    scsi_info[path] = {"hctl": hctl, "model": model, "serial": serial}

    host_str = hctl.split(":",1)[0] if ":" in hctl else ""
    host = _safe_int(host_str)
    if host is None:
      continue
    host_to_dev[host] = path
    hosts.add(host)

  # bay count derived from HCTL (0-based host -> 1-based bay)
  hctl_bay_count = (max(hosts) + 1) if hosts else len(configured)

  actual_devs = set(host_to_dev.values())

  # fallback: if HCTL missing for some disks, assign remaining disks to missing hosts
  placeholder_devs = [d for d in configured if d not in actual_devs]
  missing_hosts = [h for h in range(hctl_bay_count) if h not in host_to_dev]

  host_placeholder = {}
  for host, devp in zip(missing_hosts, placeholder_devs):
    host_placeholder[host] = devp

  # 2) Prefer by-path mapping: parse "-ata-N" from /dev/disk/by-path symlinks
  bypath_dev_to_bay = {}
  try:
    base = "/dev/disk/by-path"
    if os.path.isdir(base):
      for p in sorted(glob.glob(os.path.join(base, "*ata-*"))):
        bn = os.path.basename(p)
        if "part" in bn:
          continue
        try:
          real = os.path.realpath(p)
        except Exception:
          continue
        if not re.match(r"^/dev/sd[a-z]+$", real):
          continue
        mm = re.search(r"-ata-(\d+)(?:\.\d+)?", bn)
        if not mm:
          continue
        bay_i = _safe_int(mm.group(1))
        if bay_i is None:
          continue
        # keep the lowest bay number for a device if multiple links exist
        if real not in bypath_dev_to_bay or bay_i < bypath_dev_to_bay[real]:
          bypath_dev_to_bay[real] = bay_i
  except Exception:
    bypath_dev_to_bay = {}

  # build bay_map from by-path where possible
  for devp, bay_i in bypath_dev_to_bay.items():
    if not bay_i:
      continue
    bay_s = str(bay_i)
    bay_map[devp] = bay_s
    bay_to_dev[bay_s] = devp
    present_sata_bays.add(bay_i)

  # 3) Fill remaining disks using HCTL (host+1) if not mapped via by-path
  for host in range(hctl_bay_count):
    devp = host_to_dev.get(host) or host_placeholder.get(host)
    if not devp:
      continue
    if devp in bay_map:
      continue
    bay_i = host + 1
    bay_s = str(bay_i)
    # only assign if bay isn't already taken (avoid collisions)
    if bay_s not in bay_to_dev:
      bay_map[devp] = bay_s
      bay_to_dev[bay_s] = devp
      present_sata_bays.add(bay_i)

  # final bay count (use highest seen bay, otherwise fallback)
  if present_sata_bays:
    sata_bay_count = max(present_sata_bays)
  else:
    sata_bay_count = hctl_bay_count

except Exception:
  pass

# NVMe model/serial via lsblk (namespaces)
nvme_info = {}
try:
  out = run(["lsblk","-dn","-o","NAME,MODEL,SERIAL","-P"], timeout=6)
  for line in out.splitlines():
    if 'NAME=' not in line:
      continue
    kv = dict(re.findall(r'(\w+)="([^"]*)"', line))
    name = kv.get("NAME","")
    if re.match(r"^nvme\d+n\d+$", name):
      nvme_info["/dev/"+name] = {"model": kv.get("MODEL",""), "serial": kv.get("SERIAL","")}
except Exception:
  pass

# NVMe slot mapping (M.2-1/M.2-2) via sysfs controller PCI address ordering
nvme_slot = {}
try:
  ctrls = []
  for p in glob.glob("/sys/class/nvme/nvme[0-9]*"):
    ctrl = os.path.basename(p)  # nvme0
    addr = ""
    for cand in ("address", "device/address"):
      fp = os.path.join(p, cand)
      if os.path.exists(fp):
        try:
          addr = open(fp, "r", encoding="utf-8", errors="ignore").read().strip()
          break
        except Exception:
          pass
    if not addr:
      # fallback: parse realpath for 0000:bb:dd.f
      try:
        rp = os.path.realpath(os.path.join(p, "device"))
        m = re.search(r"(\d{4}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}\.[0-9])", rp)
        if m:
          addr = m.group(1)
      except Exception:
        pass
    ctrls.append((addr, ctrl))
  ctrls = [c for c in ctrls if c[1]]
  ctrls.sort(key=lambda x: x[0] or "")
  for idx, (_, ctrl) in enumerate(ctrls, start=1):
    nvme_slot[ctrl] = f"M.2-{idx}"
except Exception:
  pass

def nvme_bay_for_disk(devpath):
  m = re.match(r"^/dev/(nvme\d+)n\d+$", devpath)
  if not m:
    return ""
  ctrl = m.group(1)  # nvme0
  return nvme_slot.get(ctrl, "")

# md arrays
mdstat = ""
try:
  with open("/proc/mdstat","r",encoding="utf-8",errors="replace") as f:
    mdstat = f.read()
except Exception:
  mdstat = ""

arrays = []
for line in mdstat.splitlines():
  m = re.match(r"^(md\d+)\s*:\s*(.*)$", line.strip())
  if m:
    arrays.append(m.group(1))
arrays = sorted(set(arrays), key=lambda x: int(re.findall(r"\d+", x)[0])) if arrays else []

def parse_mdstat_progress(mdname):
  """Parse MD RAID progress from /proc/mdstat.

  We extract:
  - progress percentage (e.g. 6.1%)
  - finish ETA (e.g. 415.7min)
  - speed (e.g. 146413K/sec)

  Note: /proc/mdstat formats can vary; therefore we first detect the progress line
  by the '... = <pct>%' pattern and then independently extract finish/speed if present.
  """
  prog = ""
  eta = ""
  speed = ""
  block = []
  lines = mdstat.splitlines()
  for i, ln in enumerate(lines):
    if ln.startswith(mdname + " ") or ln.startswith(mdname + ":") or ln.startswith(mdname + " :"):
      block = lines[i:i+10]
      break

  for ln in block:
    mm = re.search(r"(recovery|resync|rebuild|reshape|check)\s*=\s*([0-9]+(?:\.[0-9]+)?)%", ln)
    if not mm:
      continue

    prog = mm.group(2) + "%"

    fm = re.search(r"finish=([0-9\.]+[a-zA-Z]+)", ln)
    if fm:
      eta = fm.group(1)

    sm = re.search(r"speed=([0-9]+[A-Za-z/]+)", ln)
    if sm:
      speed = sm.group(1)

  return prog, eta, speed

def parse_mdadm_detail(mdname):
  global baymap_dirty, baymap_data
  info = {
    "name": mdname,
    "level": "",
    "state_raw": "",
    "state_short": "OK",
    "raid_devs": "",
    "active_devs": "",
    "failed_devs": "",
    "spare_devs": "",
    "rebuild": "",
    "members": [],
    "mount": "",
    "speed_eta": ""
  }

  mps = get_mountpoints_for_kname(mdname)
  info["mount"] = label_from_mount(mps)

  prog, eta, speed = parse_mdstat_progress(mdname)
  if eta or speed:
    info["speed_eta"] = ("finish=" + eta if eta else "") + ((" " if eta and speed else "") + ("speed=" + speed if speed else ""))
  if prog:
    info["rebuild"] = prog

  if subprocess.call(["bash","-lc","command -v mdadm >/dev/null 2>&1"]) != 0:
    if prog:
      info["state_short"] = "SYNC"
    return info

  out = run(["mdadm","--detail", f"/dev/{mdname}"], timeout=8)

  def get_field(rx):
    m = re.search(rx, out, re.M)
    return m.group(1).strip() if m else ""

  info["level"] = get_field(r"^\s*Raid Level\s*:\s*(.+)$")
  info["state_raw"] = get_field(r"^\s*State\s*:\s*(.+)$")
  info["raid_devs"] = get_field(r"^\s*Raid Devices\s*:\s*(\d+)\s*$")
  info["active_devs"] = get_field(r"^\s*Active Devices\s*:\s*(\d+)\s*$")
  info["failed_devs"] = get_field(r"^\s*Failed Devices\s*:\s*(\d+)\s*$")
  info["spare_devs"] = get_field(r"^\s*Spare Devices\s*:\s*(\d+)\s*$")

  m = re.search(r"^\s*(?:Rebuild Status|Reconstruction Status)\s*:\s*([0-9]+)%\s*complete\s*$", out, re.M)
  if m:
    info["rebuild"] = m.group(1) + "%"

  s = (info["state_raw"] or "").lower()
  if any(x in s for x in ["recovering","rebuilding","resyncing","reshaping"]):
    info["state_short"] = "SYNC"
  if "degraded" in s:
    info["state_short"] = "DEGRADED"
  if "inactive" in s or "faulty" in s:
    info["state_short"] = "ALERT"
  if info["rebuild"] and info["state_short"] == "OK":
    info["state_short"] = "SYNC"

  lines = out.splitlines()
  start = 0
  for i, ln in enumerate(lines):
    if re.match(r"^\s*Number\s+Major\s+Minor\s+RaidDevice\s+State", ln):
      start = i+1
      break

  for ln in lines[start:]:
    if not ln.strip():
      continue
    if not re.match(r"^\s*\d+\s+\d+\s+\d+\s+(\d+|-)\s+", ln):
      continue
    parts = ln.split()
    if len(parts) < 6:
      continue
    raiddev = parts[3]
    devpath = parts[-1]
    state = " ".join(parts[4:-1])

    pd = parent_disk(devpath)

    # Primary bay mapping for mdraid: use mdadm "RaidDevice" index (usually matches tray order)
    bay = ""
    if raiddev.isdigit():
      try:
        bay = str(int(raiddev) + 1)
      except Exception:
        bay = ""

    # Fallbacks (non-standard arrays / spares): use detected bay map
    if not bay and pd:
      bay = bay_map.get(pd, "")
    if not bay and pd:
      bay = nvme_bay_for_disk(pd)

    model = scsi_info.get(pd, {}).get("model","")
    serial = scsi_info.get(pd, {}).get("serial","")
    if not model or not serial:
      ni = nvme_info.get(pd, {})
      model = model or ni.get("model","")
      serial = serial or ni.get("serial","")

    # If we have a stored bay-map, use it only as fallback (never override a computed bay)
    try:
      arr = baymap_data.get(mdname, {}) if isinstance(baymap_data.get(mdname, {}), dict) else {}
      saved = arr.get("members", {}) if isinstance(arr.get("members", {}), dict) else {}

      # Fill missing model/serial by bay (useful for removed drives)
      if (not serial or not model) and bay:
        for s, rec in saved.items():
          if not isinstance(rec, dict):
            continue
          if (rec.get("bay","") or "").strip() == str(bay):
            serial = serial or s
            model = model or (rec.get("model","") or "")
            break

      # If we still don't know the bay (rare), try to restore it from saved mapping by serial
      if serial and not bay:
        rec = saved.get(serial, {}) if isinstance(saved.get(serial, {}), dict) else {}
        b2 = (rec.get("bay","") or "").strip()
        if b2:
          bay = b2
    except Exception:
      pass

    info["members"].append({
      "disk": (pd if pd else devpath),
      "bay": bay,
      "state": state,
      "model": model,
      "serial": serial
    })

  # update baymap when array is healthy (all members present)
  try:
    rd = int(info.get("raid_devs","0") or 0)
    ad = int(info.get("active_devs","0") or 0)
    fd = int(info.get("failed_devs","0") or 0)
    if rd > 0 and ad == rd and fd == 0 and info.get("state_short") == "OK":
      ok_members = [m for m in info.get("members", []) if m.get("serial") and m.get("bay")]
      if len(ok_members) >= rd:
        baymap_data[mdname] = {
          "updated": now,
          "members": {m["serial"]: {"bay": m.get("bay",""), "model": m.get("model",""), "disk": m.get("disk","")} for m in ok_members}
        }
        baymap_dirty = True
  except Exception:
    pass

  # Fill missing bay(s) explicitly in degraded state (prevents "bay gaps" like missing Bay 2)
  # Preferred: use persisted baymap (serial->bay) to show which bay/drive is missing.
  try:
    rd = int(info.get("raid_devs","0") or 0)
    ad = int(info.get("active_devs","0") or 0)
    st = (info.get("state_short","") or "").upper()

    degraded = (rd > 0 and ad < rd) or (st in ("DEGRADED","ALERT"))
    if not degraded:
      return info

    # current members grouped by numeric bay
    by_bay = {}
    extra = []
    for mm in info.get("members", []):
      b = (mm.get("bay") or "").strip()
      if b.isdigit():
        by_bay.setdefault(int(b), []).append(mm)
      else:
        extra.append(mm)

    # saved info by bay from baymap (serial/model/disk)
    saved_by_bay = {}
    arr = baymap_data.get(mdname, {}) if isinstance(baymap_data.get(mdname, {}), dict) else {}
    saved = arr.get("members", {}) if isinstance(arr.get("members", {}), dict) else {}
    for serial, rec in saved.items():
      b = (rec.get("bay","") or "").strip()
      if b.isdigit():
        saved_by_bay[int(b)] = {"serial": serial, "model": rec.get("model","") or "", "disk": rec.get("disk","") or ""}

    # determine bay range to display
    hi = 0
    if rd > 0:
      hi = max(hi, rd)
    if by_bay:
      hi = max(hi, max(by_bay.keys()))
    if saved_by_bay:
      hi = max(hi, max(saved_by_bay.keys()))
    if present_sata_bays:
      hi = max(hi, max(present_sata_bays))
    if hi == 0 and isinstance(sata_bay_count, int) and sata_bay_count > 0:
      hi = sata_bay_count

    if hi <= 0:
      return info

    filled = []
    for bay in range(1, hi + 1):
      rows = by_bay.get(bay)
      if rows:
        filled.extend(rows)
        continue
      rec = saved_by_bay.get(bay, {})
      filled.append({
        "disk": rec.get("disk",""),
        "bay": str(bay),
        "state": tr.get("missing_role","missing/removed"),
        "model": rec.get("model",""),
        "serial": rec.get("serial",""),
      })

    info["members"] = filled + extra
  except Exception:
    pass


  # Defect count: mdadm "Failed Devices" can be 0 even if a member is missing/removed.
  # For the report, we show a combined value: failed devices if >0, otherwise missing count (Raid Devices - Active Devices).
  try:
    fd = int(info.get("failed_devs") or 0)
    raid = int(info.get("raid_devs") or 0)
    active = int(info.get("active_devs") or 0)
    missing = max(0, raid - active)
    info["defect_devs"] = str(fd if fd > 0 else missing)
  except Exception:
    info["defect_devs"] = info.get("failed_devs","")

  return info

md_infos = [parse_mdadm_detail(a) for a in arrays]

def th(txt):
  return f'<th style="padding:5px 7px;border:1px solid #dddddd;background-color:#f3f3f3;font-size:12px;">{html.escape(txt)}</th>'

def td(txt, hl=False):
  st = "padding:4px 6px;border:1px solid #dddddd;font-size:12px;text-align:center;white-space:nowrap;"
  if hl:
    st += "background-color:#ffe6e6;font-weight:bold;"
  return f'<td style="{st}">{html.escape(str(txt) if txt is not None else "")}</td>'

def td_left(txt, hl=False):
  st = "padding:4px 6px;border:1px solid #dddddd;font-size:12px;text-align:left;"
  if hl:
    st += "background-color:#ffe6e6;font-weight:bold;"
  return f'<td style="{st}">{html.escape(str(txt) if txt is not None else "")}</td>'

def is_bad_state(s):
  sl = (s or "").lower()
  return any(x in sl for x in ["faulty","removed","degraded","inactive","missing","fehlend"])

def is_rebuild_state(s):
  sl = (s or "").lower()
  return any(x in sl for x in ["rebuilding","recovering","resync","spare"])

def bay_sort_int(b):
  b = (b or "").strip()
  if b.isdigit():
    return int(b)
  m = re.match(r"^M\.2-(\d+)$", b)
  if m:
    return 1000 + int(m.group(1))
  return 9999


parts = []
parts.append("<html><head>")
parts.append('<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />')
parts.append(f"<title>{html.escape(nas)} RAID Report</title>")
parts.append("</head><body style=\"font-family:Segoe UI,Arial,sans-serif;font-size:13px;color:#333333;\">")

parts.append(f'<h2 style="font-weight:600;font-size:18px;margin-bottom:4px;">{html.escape(tr["title"])} {html.escape(nas)}</h2>')
parts.append(
  f'<p style="margin-top:0;margin-bottom:10px;">'
  f'{html.escape(tr["status"])}: <strong>{html.escape(kind)}</strong><br />'
  f'{html.escape(tr["time"])}: {html.escape(now)}<br />'
  f'{html.escape(tr["host"])}: {html.escape(nas)}'
  f'</p>'
)

parts.append(f'<h3 style="font-size:15px;margin-bottom:4px;margin-top:16px;">{html.escape(tr["md"])}</h3>')
parts.append('<table style="border-collapse:collapse;width:100%;max-width:1100px;">')
parts.append("<tr>")
for col in (tr["array"], tr["mount"], tr["level"], tr["state"], tr["active"], tr["failed"], tr["spare"], tr["progress"], tr["speed"]):
  parts.append(th(col))
parts.append("</tr>")

if md_infos:
  for info in md_infos:
    st_short = info.get("state_short","")
    active = f'{info.get("active_devs","")}/{info.get("raid_devs","")}' if info.get("raid_devs") else ""

    # Row highlight:
    # - Red: degraded/alert
    # - Yellow: rebuild/resync/check/recover
    row_bg = ""
    if st_short in ("DEGRADED","ALERT","ALARM"):
      row_bg = "#ffe6e6"
    elif bool(info.get("rebuild")) or st_short in ("RECOVER","RESYNC","REBUILD","CHECK"):
      row_bg = "#fff2cc"

    tr_style = f' style="background-color:{row_bg}; font-weight:bold;"' if row_bg else ""
    parts.append(f"<tr{tr_style}>")
    parts.append(td(info.get("name",""), False))
    parts.append(td_left(info.get("mount",""), False))
    parts.append(td(info.get("level",""), False))
    parts.append(td(st_short, False))
    parts.append(td(active, False))
    parts.append(td(info.get("defect_devs", info.get("failed_devs","")), False))
    parts.append(td(info.get("spare_devs",""), False))
    parts.append(td(info.get("rebuild",""), False))
    parts.append(td_left(info.get("speed_eta",""), False))
    parts.append("</tr>")
else:
  parts.append(f'<tr><td colspan="9" style="padding:5px 7px;border:1px solid #dddddd;font-size:12px;">{html.escape(tr["no_arrays"])}</td></tr>')
parts.append("</table>")

for info in md_infos:
  members = info.get("members") or []
  if not members:
    continue

  title = info.get("mount","") or info.get("name","")
  if info.get("mount",""):
    title = f'{info["mount"]} ({info["name"]})'

  parts.append(f'<h3 style="font-size:15px;margin-bottom:4px;margin-top:18px;">{html.escape(tr["member_table"])}: {html.escape(title)}</h3>')
  parts.append('<table style="border-collapse:collapse;width:100%;max-width:1100px;">')
  parts.append("<tr>")
  for col in (tr["bay"], tr["disk"], tr["role"], tr["model"], tr["serial"]):
    parts.append(th(col))
  parts.append("</tr>")

  for m in sorted(members, key=lambda m: (bay_sort_int(m.get("bay","")), m.get("disk",""))):
    role = m.get("state","")

    # Full-row highlight:
    # - Red: missing/removed/faulty/failed
    # - Yellow: rebuild/resync/spare
    row_bg = ""
    if is_bad_state(role):
      row_bg = "#ffe6e6"
    elif is_rebuild_state(role):
      row_bg = "#fff2cc"

    tr_style = f' style="background-color:{row_bg}; font-weight:bold;"' if row_bg else ""
    parts.append(f"<tr{tr_style}>")
    parts.append(td(m.get("bay",""), False))
    parts.append(td_left(m.get("disk",""), False))
    parts.append(td_left(role, False))
    parts.append(td_left(m.get("model",""), False))
    parts.append(td_left(m.get("serial",""), False))
    parts.append("</tr>")
  parts.append("</table>")

if show_details:
  parts.append(f'<h3 style="font-size:15px;margin-bottom:4px;margin-top:18px;">{html.escape(tr["details"])}</h3>')
  esc = html.escape(details_text)
  parts.append('<pre style="margin:0;border:1px solid #dddddd;padding:10px;font-family:Consolas,Menlo,monospace;font-size:12px;white-space:pre-wrap;word-wrap:break-word;">')
  parts.append(esc)
  parts.append("</pre>")

note_html = html.escape(tr["note"]).replace("\n", "<br>")
parts.append(f'<p style="margin-top:18px;font-size:11px;color:#777777;">{note_html}</p>')
parts.append("</body></html>")

# persist bay mapping (for missing-bay detection)
try:
  if baymap_dirty and baymap_path:
    tmpf = baymap_path + ".tmp"
    with open(tmpf, "w", encoding="utf-8") as f:
      json.dump(baymap_data, f, ensure_ascii=False, indent=2)
    os.replace(tmpf, baymap_path)
except Exception:
  pass

sys.stdout.write("".join(parts))
PY

  rm -f "$tmp" 2>/dev/null || true
}

send_mail() {
  local subject="$1"
  local body_text="$2"
  local body_html="${3:-}"

  if ! command -v python3 >/dev/null 2>&1; then
    log "$(msg PYTHON_MISSING)"
    return 1
  fi

  if [[ -z "${SMTP_SERVER:-}" || -z "${SMTP_PORT:-}" || -z "${MAIL_FROM:-}" || -z "${MAIL_TO:-}" ]]; then
    log "$(msg SMTP_CFG_INCOMPLETE)"
    return 1
  fi

  local subj
  subj="$(trim_subject_64 "$subject")"

  SUBJECT="$subj" BODY_TEXT="$body_text" BODY_HTML="$body_html" \
  SMTP_SERVER="${SMTP_SERVER:-}" SMTP_PORT="${SMTP_PORT:-}" SMTP_USER="${SMTP_USER:-}" SMTP_PASS="${SMTP_PASS:-}" \
  MAIL_FROM="${MAIL_FROM:-}" MAIL_TO="${MAIL_TO:-}" \
  SMTP_STARTTLS="$SMTP_STARTTLS" SMTP_SSL="$SMTP_SSL" SMTP_TIMEOUT="$SMTP_TIMEOUT" \
  python3 - <<'PY'
import os, smtplib, ssl
from email.message import EmailMessage

host = os.environ.get("SMTP_SERVER","")
port = int(os.environ.get("SMTP_PORT","0") or 0)
user = os.environ.get("SMTP_USER","")
pwd  = os.environ.get("SMTP_PASS","")
frm  = os.environ.get("MAIL_FROM","")
to_  = os.environ.get("MAIL_TO","")

timeout = int(os.environ.get("SMTP_TIMEOUT","20") or 20)
starttls = os.environ.get("SMTP_STARTTLS","1") == "1"
use_ssl  = os.environ.get("SMTP_SSL","0") == "1"

subject   = os.environ.get("SUBJECT","(no subject)")
body_text = os.environ.get("BODY_TEXT","")
body_html = os.environ.get("BODY_HTML","")

msg = EmailMessage()
msg["Subject"] = subject
msg["From"] = frm
msg["To"] = to_

msg.set_content(body_text, charset="utf-8")
if body_html.strip():
    msg.add_alternative(body_html, subtype="html", charset="utf-8")

context = ssl.create_default_context()

if use_ssl:
    with smtplib.SMTP_SSL(host, port, timeout=timeout, context=context) as s:
        if user:
            s.login(user, pwd)
        s.send_message(msg)
else:
    with smtplib.SMTP(host, port, timeout=timeout) as s:
        s.ehlo()
        if starttls:
            s.starttls(context=context)
            s.ehlo()
        if user:
            s.login(user, pwd)
        s.send_message(msg)
PY
}

localize_kind() {
  local k="$1"
  if is_en; then
    case "$k" in
      ALARM) echo "ALERT" ;;
      RECOVERY) echo "RECOVERY" ;;
      FORCED) echo "FORCED" ;;
      INFO) echo "INFO" ;;
      OK) echo "OK" ;;
      *) echo "$k" ;;
    esac
  else
    echo "$k"
  fi
}

main_once() {
  if [[ "$TEST_MAIL" == "1" ]]; then
    local kind="INFO"
    local kind_disp
    kind_disp="$(localize_kind "$kind")"
    local subj="${SUBJECT_PREFIX} ${NAS_NAME} RAID-Report [TEST]"
    local text
    if is_en; then
      text="Test mail from raidwatch.sh on ${NAS_NAME}."
      subj="${SUBJECT_PREFIX} ${NAS_NAME} RAID Report [TEST]"
    else
      text="Testmail von raidwatch.sh auf ${NAS_NAME}."
    fi

    local html=""
    if [[ "$MAIL_FORMAT" == "html" ]]; then
      html="$(make_html_report "$kind_disp" "$text")"
    fi

    # Footer (version + copyright)
    text="${text}"$'\n\n'"$(msg FOOTER_NOTE)"$'\n'"$(msg FOOTER_COPYRIGHT)"
    send_mail "$subj" "$text" "$html"
    log "$(msg TESTMAIL_SENT)"
    return 0
  fi

  load_state

  local r problem report
  r="$(build_report_text)"
  problem="${r%%|*}"
  report="${r#*|}"

  local now hash
  now="$(date +%s 2>/dev/null || python3 -c 'import time;print(int(time.time()))')"
  hash="$(hash_text "$report")"

  local should_send="0"
  local kind="OK"

  if [[ "$problem" == "1" ]]; then
    kind="ALARM"
    if [[ "${LAST_PROBLEM:-0}" != "1" ]]; then
      should_send="1"
    elif (( now - ${LAST_ALERT_EPOCH:-0} >= ALERT_COOLDOWN_SECONDS )); then
      should_send="1"
    elif [[ "$ALERT_ON_CHANGE" == "1" && "${LAST_HASH:-}" != "$hash" ]]; then
      should_send="1"
    fi
  else
    if [[ "${LAST_PROBLEM:-0}" == "1" ]]; then
      kind="RECOVERY"
      should_send="1"
    elif [[ "$ALERT_ON_CHANGE" == "1" && "${LAST_HASH:-}" != "$hash" ]]; then
      kind="INFO"
      should_send="1"
    fi
  fi

  if [[ "$FORCE_SEND" == "1" ]]; then
    should_send="1"
    [[ "$kind" == "OK" ]] && kind="FORCED"
  fi

  local kind_disp
  kind_disp="$(localize_kind "$kind")"

  local subj
  if is_en; then
    subj="${SUBJECT_PREFIX} ${NAS_NAME} RAID Report [${kind_disp}]"
  else
    subj="${SUBJECT_PREFIX} ${NAS_NAME} RAID-Report [${kind_disp}]"
  fi

  local body_text="$report"
  local footer_text
  footer_text="$(printf "%s\\n%s" "$(msg FOOTER_NOTE)" "$(msg FOOTER_COPYRIGHT)")"
  body_text="${body_text}"$'\n\n'"${footer_text}"
  local body_html=""

  if [[ "$MAIL_FORMAT" == "html" ]]; then
    body_html="$(make_html_report "$kind_disp" "$report")"
  fi

  if [[ "$should_send" == "1" ]]; then
    if send_mail "$subj" "$body_text" "$body_html"; then
      log "$(msg MAIL_SENT) $subj"
      save_state "$hash" "$problem" "$now"
      return 0
    else
      log "$(msg MAIL_SEND_FAILED)"
      save_state "$hash" "$problem" "${LAST_ALERT_EPOCH:-0}"
      return 1
    fi
  else
    log "$(msg NO_MAIL_NEEDED) $kind_disp"
    save_state "$hash" "$problem" "${LAST_ALERT_EPOCH:-0}"
  fi
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --once) MODE="once"; shift ;;
    --loop) MODE="loop"; shift ;;
    --force) FORCE_SEND="1"; shift ;;
    --test-mail) TEST_MAIL="1"; shift ;;
    -h|--help) usage; exit 0 ;;
    *) echo "$(msg UNKNOWN_ARG) $1"; usage; exit 2 ;;
  esac
done

if [[ "$MODE" == "once" ]]; then
  main_once
else
  log "$(msg LOOP_STARTED) (every ${SLEEP_SECONDS}s)."
  while true; do
    main_once || true
    sleep "$SLEEP_SECONDS"
  done
fi
